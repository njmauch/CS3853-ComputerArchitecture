# -- coding utf-8 --
CompArchProject_Main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    httpscolab.research.google.comdrive1201nfbgeyXvCm0NBPcvl-E1O_iFTUYHw

import sys
import math
import re
print(sys.argv)
import pprint
import random
import time
from collections import deque

def Log2(x) 
  return (math.log10(x)  math.log10(2)) 

#Show the parameters
print(Cache Simulator - CS 3853 - Team 03)

print(nTrace File ,sys.argv[2])
print(n Cache Input Parameters n)
print(Cache Sizettt,sys.argv[4],  kb)
print(Block Sizettt,sys.argv[6],  bytes)
print(Associativityttt,sys.argv[8])
rep_policy = sys.argv[10]
if(rep_policy == RR)
  print(Replacement Policytt,Round Robin)
elif(rep_policy == RND)
  print(Replacement Policytt,Random)
elif(rep_policy == LRU)
  print(Replacement Policytt,Least Recently Used)


#Calculate the values
print(n Cache Calculated Values n)
#cache_size = int(sys.argv[4])
block_size = int(sys.argv[6])
associativity = int(sys.argv[8])
cache_bits = math.ceil(Log2(int(sys.argv[4])  1000))
offset = math.ceil(Log2(int(sys.argv[6])))

#sets = cache_bits  ( offset + math.ceil(Log2(associativity)))
index_bits = cache_bits - (offset + math.ceil(Log2(associativity)))
tag_bits = 32 - index_bits - offset 


block_count = 2  (cache_bits - offset)


print(Block count ,  block_count)
print(Total # Blocks tt, block_count)
print(Tag Size ttt,tag_bits, bits)
print(Index Size ttt, index_bits, bits)
print(Total # Rows ttt, 2  index_bits)

overhead = (2  index_bits)  (tag_bits + 1)  8  associativity
print(Overhead Size ttt,overhead,Bytes)

total_impl = 2  cache_bits + overhead
print(Implementation Memory Size t,(total_impl  0.0009765625),  KBt({}.format(total_impl), Bytes))

cost = int(total_impl  0.0009765625)  .05
print(Cost tttt $%.2f % (cost))


###############################################################################
#Read the trace file
print(nn  Reading Trace File )

my_file = open(sys.argv[2], 'r') 
Lines = my_file.readlines()

addr = []
readSize = []
for line in Lines 
    if line == 'n'
        continue
    tokenM = line.split()
    if tokenM[0] == 'EIP'
        if tokenM[2] == '00000000'
            continue
        addr.append(tokenM[2])
        fetchSize = tokenM[1]
        fetchSize = fetchSize.strip('(')
        fetchSize = fetchSize.strip(')')
        fetchSize = int(fetchSize)
        readSize.append(fetchSize)
    else
        if tokenM[1] == '00000000'
            continue
        addr.append(tokenM[1])
        readSize.append(4)
        if tokenM[4] == '00000000'
            continue
        addr.append(tokenM[4])
        readSize.append(4)

number_of_rows = block_count  associativity

tags = [[-1 for i in range(0, associativity)] for i in range(0, int(number_of_rows))]
valid = [[0 for i in range(0, associativity)] for i in range(0, int(number_of_rows))]
timeTable  = [ [ 0 for i in range(associativity) ] for j in range(0, int(number_of_rows)) ]

programTimer = 0
hit = 0
conf_miss = 0
total_count = 0
comp_miss = 0
for address in addr
    total_count += 1
    offset = int(address, 16) % block_size
    row = (int(address,16)  block_size) % number_of_rows
    tag = int(address,16)  (block_size  number_of_rows)
    miss_flag = 1
    row = int(row)
    tag = int(tag)
    
    for k in range(associativity)
        if tags[row][k] == tag
            hit += 1
            if rep_policy == 'LRU'
                timeTable[row][k]=programTimer
            miss_flag = 0
            break
       
    if rep_policy == 'LRU' or rep_policy == 'RR'
        if miss_flag == 1
            for l in range(associativity)
                if valid == 0
                    tags[row][l] = tag
                    timeTable[row][l]=programTimer
                    valid[row][j] = 1
                    miss_flag = 0
                    comp_miss += 1
                    break
        if miss_flag == 1
            min=timeTable[row][0]
            min_k = 0
            for m in range(associativity)
                if timeTable[row][k]min
                    min=timeTable[row][k]
                    min_k = k
            tags[row][min_k] = tag
            timeTable[row][min_k]=programTimer
            comp_miss += 1
            miss_flag = 0
    elif rep_policy == 'RND'
        if miss_flag == 1
            for n in range(associativity)
                if valid == 0
                    tags[row][n] = tag
                    valid[row][n] = 1
                    miss_flag = 0
                    comp_miss += 1
                    break
        if miss_flag == 1
            randomNum = random.randint(0, associativity-1)
            tags[row][randomNum] = tag
            comp_miss += 1
            miss_flag = 0
    programTimer += 1
    

print(Comp Miss  , comp_miss)
print(Conf miss , conf_miss)
print(Hit , hit)
print(Total cache accesses , total_count)