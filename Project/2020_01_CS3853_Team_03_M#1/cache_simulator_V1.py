# -*- coding: utf-8 -*-
"""CompArchProject_Main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1201nfbgeyXvCm0NBPcvl-E1O_iFTUYHw
"""
import sys
import math
import re
print(sys.argv)

def Log2(x): 
  return (math.log10(x) / math.log10(2)); 

#Show the parameters
print("Cache Simulator - CS 3853 - Team 03")

print("\nTrace File: ",sys.argv[2])
print("\n***** Cache Input Parameters *****\n")
print("Cache Size:\t\t\t",sys.argv[4], " kb")
print("Block Size:\t\t\t",sys.argv[6])
print("Associativity:\t\t\t",sys.argv[8])
rep_policy = sys.argv[10]
if(rep_policy == "RR"):
  print("Replacement Policy:\t\t","Round Robin")
elif(rep_policy == "RND"):
  print("Replacement Policy:\t\t","Random")
elif(rep_policy == "LRU"):
  print("Replacement Policy:\t\t","Least Recently Used")


#Calculate the values
print("\n***** Cache Calculated Values *****\n")
#cache_size = int(sys.argv[4])
block_size = int(sys.argv[6])
associativity = int(sys.argv[8])
cache_bits = math.ceil(Log2( int(sys.argv[4]) *1000 ))
offset = math.ceil(Log2( int(sys.argv[6])))

#sets =  cache_bits / ( offset +  math.ceil(Log2(associativity)))

index_bits = cache_bits - (offset + math.ceil(Log2(associativity)))
tag_bits = 32 - index_bits - offset 


block_count = 2 ** (cache_bits - offset)


print("Block count: ",  block_count)
print("Total # Blocks: \t\t", block_count)
print("Tag Size: \t\t\t",tag_bits," bits")
print("Index Size: \t\t\t", index_bits," bits")
print("Total # Rows:: \t\t\t", 2 ** index_bits)

overhead = (2 ** index_bits) * (tag_bits + 1) / 8 * associativity
print("Overhead Size: \t\t\t",overhead,"Bytes")

total_impl = 2**cache_bits + overhead
print("Implementation Memory Size: \t",(total_impl* 0.0009765625), " KB\t({}".format(total_impl)," Bytes)")

cost = int(total_impl * 0.0009765625) * .05
print("Cost: \t\t\t\t $%.2f" %(cost))


###############################################################################
#Read the trace file
print("\n\n ***** Reading Trace File *****")

my_file = open(sys.argv[2], 'r') 
length_pattern = re.compile("\([0-9][0-9]\)\:")
address_pattern = re.compile("\): [0-9a-fA-F]{8}\s[-,0]{0,8}")
dest_pattern = re.compile("destM: [0-9a-fA-F]{8}\s[-,0]{0,8}")
source_pattern = re.compile("srcM: [0-9a-fA-F]{8}\s[-,0]{0,8}")
add_pattern = re.compile("[0-9a-fA-F]{8}")#\s[-,0]{0,8}")
number_pattern = re.compile("[0-9]{2}")
Lines = my_file.readlines() 
# Read each line
i=0
for line in Lines: 
    # search the line for an occurance of a length
    # in the format "(xx):"
    # returns only one occurance
    lengthMatch = length_pattern.search(line)
    # search line for all occurances of an address
    # returns a tuple of all addresses found
    matches = re.findall(address_pattern,line)
    sourceMatches = re.findall(dest_pattern,line)
    destMatches = re.findall(source_pattern,line)
    for addMatch in matches:
        address = add_pattern.search(addMatch)
        print("0x" + address.group(0),end = '')
    if lengthMatch:
        #searches again to remove the "():"
        number = number_pattern.search(lengthMatch.group(0))
        print(": (" + number.group(0) + ")")
        i += 1
    for addMatch in sourceMatches:
        address = add_pattern.search(addMatch)
        if address.group(0) != '00000000':
            print("0x" + address.group(0) + ": (04)")
            i += 1
    for addMatch in destMatches:
        address = add_pattern.search(addMatch)
        if address.group(0) != '00000000':
            print("0x" + address.group(0) + ": (04)")
            i +=1
    if i == 20:
        break



