# -*- coding: utf-8 -*-
"""CompArchProject_Main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1201nfbgeyXvCm0NBPcvl-E1O_iFTUYHw
"""
import sys
import math
import re
print(sys.argv)
import pprint
import random
import time

instruction = 0
cycles = 0
total = 0
hit=0
comp_miss=0
conf_miss=0
miss = 0
program_timer = 0

def check_cache(addr, read_size, tags, associativity, rep_policy, valid, time_table, block_size):
    global total
    global hit
    global comp_miss
    global miss
    global conf_miss
    global program_timer
    global cycles 

    addr = bin(int(addr, 16))[2:].zfill(32)
    tag = addr[:tag_bits]
    index = addr[tag_bits:(tag_bits + index_bits)]
    offset = addr[(tag_bits + index_bits):]
    tag = int(tag, 2)
    index = int(index, 2)
    offset = int(offset, 2)
    miss_flag = 1
    for i in range(0, associativity):
        if tags[index][i] == tag:
            hit += 1
            if rep_policy == 'LRU':
                time_table[index][i] = program_timer
            miss_flag = 0
            return
    cycles += 3 * math.ceil(block_size/4)
    if rep_policy == 'LRU' or rep_policy == 'RR':
        if miss_flag == 1:
            for j in range(0, associativity):
                if valid[index][j] == 0:
                    tags[index][j] = tag
                    time_table[index][j] = program_timer
                    valid[index][j] = 1
                    miss_flag = 0
                    comp_miss += 1
                    return
            min = time_table[index][0]
            min_k = 0
            for k in range(0, associativity):
                if time_table[index][k] < min:
                    min = time_table[index][k]
                    min_k = k
            tags[index][min_k] = tag
            time_table[index][min_k] = program_timer
            conf_miss += 1
            miss_flag = 0
            return
    elif rep_policy == 'RND':
        if miss_flag == 1:
            for j in range(0, associativity):
                if valid[index][j] == 0:
                    tags[index][j] = tag
                    valid[index][j] = 1
                    miss_flag = 0
                    comp_miss += 1
                    return
            randNum = random.randint(0, associativity-1)
            tags[index][randNum] = tag
            conf_miss += 1
            miss_flag = 0
    program_timer += 1
    return
       
def Log2(x): 
  return (math.log10(x) / math.log10(2)) 

#Show the parameters
print("Cache Simulator - CS 3853 - Team 03")

print("\nTrace File: ",sys.argv[2])
print("\n***** Cache Input Parameters *****\n")
print("Cache Size:\t\t\t",sys.argv[4], " kb")
print("Block Size:\t\t\t",sys.argv[6], " bytes")
print("Associativity:\t\t\t",sys.argv[8])
rep_policy = sys.argv[10]
if(rep_policy == "RR"):
  print("Replacement Policy:\t\t","Round Robin")
elif(rep_policy == "RND"):
  print("Replacement Policy:\t\t","Random")
elif(rep_policy == "LRU"):
  print("Replacement Policy:\t\t","Least Recently Used")


#Calculate the values
print("\n***** Cache Calculated Values *****\n")
#cache_size = int(sys.argv[4])
block_size = int(sys.argv[6])
associativity = int(sys.argv[8])
cache_bits = math.ceil(Log2(int(sys.argv[4]) * 1000))
offset = math.ceil(Log2(int(sys.argv[6])))

#sets = cache_bits / ( offset + math.ceil(Log2(associativity)))
index_bits = cache_bits - (offset + math.ceil(Log2(associativity)))
tag_bits = 32 - index_bits - offset 


block_count = 2 ** (cache_bits - offset)


print("Block count: ",  block_count)
print("Total # Blocks: \t\t", block_count)
print("Tag Size: \t\t\t",tag_bits," bits")
print("Index Size: \t\t\t", index_bits," bits")
print("Total # Rows:: \t\t\t", 2 ** index_bits)

overhead = (2 ** index_bits) * (tag_bits + 1) / 8 * associativity
print("Overhead Size: \t\t\t",overhead,"Bytes")

total_impl = 2 ** cache_bits + overhead
print("Implementation Memory Size: \t",(total_impl * 0.0009765625), " KB\t({}".format(total_impl)," Bytes)")

cost = int(total_impl * 0.0009765625) * .05
print("Cost: \t\t\t\t $%.2f" % (cost))


###############################################################################
#Read the trace file
print("\n\n *****  Cache Simulation Results *****")

my_file = open(sys.argv[2], 'r') 
Lines = my_file.readlines()


tags = [[0 for i in range(0, associativity)] for i in range(0, 2 ** index_bits)]
valid = [[0 for i in range(0, associativity)] for i in range(0, 2 ** index_bits)]
time_table = [[0 for i in range(0, associativity)] for i in range(0, 2 ** index_bits)]

for line in Lines:
    if line == '\n':
        continue
    tokenM = line.split()
    if tokenM[0] == 'EIP':
        addr = tokenM[2]
        read_size = tokenM[1].strip(':()')
        check_cache(addr, read_size, tags, associativity, rep_policy, valid, time_table, block_size)
        instruction += 1
        total += 1
        cycles += 2
    else:
        dstM = tokenM[1]
        srcM = tokenM[4]
        
        if dstM != '00000000':
            check_cache(dstM, 4, tags, associativity, rep_policy, valid, time_table, block_size)
            total += 1
            cycles += 1
        if srcM != '00000000':
            check_cache(srcM, 4, tags, associativity, rep_policy, valid, time_table, block_size)
            total += 1
            cycles += 1
    
print("\nTotal Cache Accesses:     ", total)
print("Cache Hits:               ", hit)
print("Cache Misses:             ", comp_miss + conf_miss)
print("--- Compulsary Misses:    ", comp_miss)
print("--- Conflict Misses:      ", conf_miss)
print("\n ***** ***** CACHE HIT & MISS RATE: ***** ***** ")
hit_rate = (hit * 100) / total
print("Hit Rate:                 {:0.4f}".format(hit_rate), "%")
print("Miss Rate:                {:0.4f}".format(100 - hit_rate), "%")
print("CPI:                      {:0.2f}".format(cycles/instruction))


unused_cache_blocks = block_count - comp_miss
temp = (block_size * 8) + tag_bits + 1
temp = temp / 8
unused_cache = (unused_cache_blocks * temp) / 1024
waste = unused_cache * .05
total_cache_size = total_impl * 0.0009765625

print("Unused Cache Space:       {:0.2f}".format(unused_cache), " / {:0.2f}".format(total_cache_size)," KB = {:0.2f}".format((unused_cache/total_cache_size)*100), "% Waste: ${:0.2f}".format(waste))
print("Unused Cache Blocks:       ", unused_cache_blocks, " / ", block_count)